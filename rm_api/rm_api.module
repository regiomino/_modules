<?php

function rm_api_menu() {
    $items = array();
    $items['simplefaxcallback'] = array(
        'page callback' => 'rm_api_simplefax_callback',
        'access arguments' => array('access content'),
        'type' => MENU_NORMAL_ITEM,
    );
    return $items;
}

/**
 * Method for creating new node objects.
 *
 * @param $type
 * 		The content type of the node
 *
 * @param $title
 *		The node title
 *
 * @param $lang
 *		The language of the node
 *
 * @param $author
 *		The author of the node
 *
 * @param $status
 *		The publishing status of the node
 *
 * @param $suppressed
 *		Custom publishing option
 *
 * @param $sticky
 *		The sticky option of the node
 *
 * @param $promote
 *		The promote option of the node
 *
 * @return object
 */
function rm_api_create_new_node($type = '', $title = '', $lang = '', $author = 0, $status = 0, $suppressed = 0, $sticky = 0, $promote = 0, $prospect = 0) {
	//Define new node
	$new_node = new stdClass();
	$new_node->type = $type;
	$new_node->is_new = TRUE;
	
	//Store title
	$new_node->title = $title;
	
	//Prepare object
	node_object_prepare($new_node);
	
	//Define language
	$new_node->language = $lang;
	
	//Define as guest content
	$new_node->uid = $author;
	
	//Store states
	$new_node->status = $status;
	$new_node->suppressed = $suppressed;
	$new_node->sticky = $sticky;
	$new_node->promote = $promote;
    $new_node->prospect = $prospect;
	
	//Submit and save node
	$new_node = node_submit($new_node);
	node_save($new_node);
	
	return $new_node;
}

/**
 * Method for creating csv files.
 *
 * @param $array
 * 		A multidimensional array. For each line the array contains another
 *		array with the items in the order they are supposed to be output
 *
 * @param $filename
 *		The name of the file
 *
 * @param $delimiter
 *		The delimiter for the csv items
 *
 * @param $return
 *		Whether the file should be output with the given filename or returned as a file object
 *
 * @return string
 */
function rm_api_array_to_csv_download($array, $filename = "export.csv", $delimiter=";", $return = FALSE) {
	if($return) {
		$time = time();
		$filepath = 'private://' . $time . '.csv';
		$f = fopen($filepath, 'w');
		foreach ($array as $line) {
			fputcsv($f, $line, $delimiter);
		}
		fclose($f);
		return $filepath;
	}
	else {
		header('Content-Type: application/csv; charset=UTF-8');
		header('Content-Disposition: attachement; filename="'.$filename.'";');
		$f = fopen('php://output', 'w');
		foreach ($array as $line) {
			fputcsv($f, $line, $delimiter);
		}
		die();
	}
}

/**
 * Method for deleting a specific field collection item in a field collection
 *
 * @param $entity_type
 * 		The entity_type that the field collection is bound to, e.g. 'node' or 'user'
 *
 * @param $entity_id
 *		The entity_id of the entity_type
 *
 * @param $field_collection_name
 *		The name of the host field collection
 *
 * @param $delta
 *		The delta of the field collection item within the field collection. Default is 0.
 *		If this is set to -1 all field collection items are removed from the field collection.
 *
 * @param $lang
 *		The language of the field collection item. Default is LANGUAGE_NONE
 *
 * @return string
 */
function rm_api_delete_fci($entity_type, $entity_id, $field_collection_name, $delta = 0, $lang = LANGUAGE_NONE) {
	//Load entity object
	$object = entity_load($entity_type, array($entity_id));
	//Define array for storing of to be deleted field collection ids
	$field_collection_item_values = array();
	if($delta < 0) {
		//Delete all field collection items from field collection
		foreach ($object[$entity_id]->{$field_collection_name}[$lang] as $key => $value) {
			//Store to be deleted field collection id in array
			$field_collection_item_values[] = $value['value'];
			//Unset field collection item from field collection
			unset($object[$entity_id]->{$field_collection_name}[$lang][$key]);
		}
	}
	else {
		//Store to be deleted field collection id in array
		$field_collection_item_values[] = $object[$entity_id]->{$field_collection_name}[$lang][$delta]['value'];
		//Unset field collection item from field collection
		unset($object[$entity_id]->{$field_collection_name}[$lang][$delta]);
		//Reset the array to zero-based sequential keys
		$object[$entity_id]->{$field_collection_name}[$lang] = array_values($object[$entity_id]->{$field_collection_name}[$lang]);
	}
	//Delete all unset field collection items from database
	entity_delete_multiple('field_collection_item', $field_collection_item_values);
	//Save entity
	entity_save($entity_type, $object[$entity_id]);
}

/**
 * Method for attaching a field api widget to a custom form
 * This only works for fields of a specific content, so the default
 * values of that content will be present within the field unless
 * you alter it afterwards.
 *
 * @param $field_name
 * 		A string with the name of the field (e.g. field_body)
 *
 * @param $entity_type
 *		A string with the entity_type (e.g. 'node')
 *
 * @param $bundle
 *		An entity object of the given entity type that contains the field
 *
 * @param $entity
 *		An entity object of the given entity type that contains the field
 *
 * @param $form
 *		The form array that the field shall be attached to
 *
 * @param $form_state
 *		The current state of the form
 *
 * @param $langcode
 *		The language of the field. Defaults to NULL, which is the site language
 */
function rm_api_attach_field_to_form($field_name, $entity_type, $bundle, $entity, &$form, &$form_state, $langcode = NULL) {

	$instances = field_info_instances($entity_type, $bundle);
  $field_name = $instances[$field_name];
	
  // Set #parents to 'top-level' if it doesn't exist.
  $form += array('#parents' => array());

  // If no language is provided use the default site language.
  $options = array(
    'language' => field_valid_language($langcode),
    'default' => TRUE,
  );
  module_load_include("inc","ctools","includes/fields");
  $form += (array) ctools_field_invoke_field($field_name, 'form', $entity_type, $entity, $form, $form_state, $options);
}

/**
 * Method for validating if all required fields of a node are filled with values
 *
 * @param $nid
 * @param $lang
 * @return boolean
 */
function rm_api_node_validate_required($nid, $lang = LANGUAGE_NONE) {
	$nodeobject = node_load($nid);
	$fields = field_info_instances('node', $nodeobject->type);
	$return = array();
	foreach($fields as $field_name => $field_definition) {
		if($field_definition['required']) {
			if(empty($nodeobject->{$field_name}[$lang])) $return[] = $field_name;
		}
	}
	return $return;
}

/**
 * Method for validating if all required fields of a node are filled with values
 *
 * @param $nid
 */
function rm_api_node_publish($nid) {
	$nodeobject = node_load($nid);
	$nodeobject->status = 1;
	node_save($nodeobject);
}

/**
 * Method for changing the type of a node and removing all
 * fields that are not present within the new node type anymore
 *
 * @param $nid
 * @param $nodetype
 */
function rm_api_change_node_type($nid, $nodetype) {
	//Get field list for the new content type
	$fields_for_new_type = field_info_instances('node', $nodetype);
	//Load the node object that shall be converted
	$nodeobject = node_load($nid);
	//Get field list for the old content type
	$fields_for_old_type = field_info_instances('node', $nodeobject->type);
	
	//Iterate through all fields of the old content type
	foreach($fields_for_old_type as $old_field_name => $old_field_definitions) {
		//If a field of the old content type does not exist within the new content type then remove it from the nodeobject
		if(!array_key_exists($old_field_name, $fields_for_new_type)) unset($nodeobject->$old_field_name);
	}
	//Save the node to properly remove the unset fields
	node_save($nodeobject);
	//Change the type
	$nodeobject->type = $nodetype;
	//Save the node again
	node_save($nodeobject);
}

/**
 * Method for exporting an xls file
 *
 * @param $header
 * @param rows
 * @param $filename
 * @param $return
 */
function rm_api_excel_export($header, $rows, $filename = 'exports.xls', $return = TRUE) {
  module_load_include('inc', 'phpexcel');
  $headers['default'] = $header;
  $data['default'] = $rows;
  $dir = file_stream_wrapper_get_instance_by_uri('private://')->realpath();
  $filename = 'exports.xls';
  $path = "$dir/$filename";
  $options = array('format' => 'xls');
  $result = phpexcel_export($headers, $data, $path, $options);
  if ($result == PHPEXCEL_SUCCESS) {
		if($return) {
			$fp = fopen($path, 'rb');
			header('Content-type: application/vnd.ms-excel');
			header('Content-Disposition: attachment; filename="' . $filename . '"');
			fpassthru($fp);
			exit;
		}
  }
  else {
    drupal_set_message(t("An error occured while creating the xls file!"), 'error');
  }
}

/**
 * Method for determining if a given timestamp is a holiday
 *
 * @param $timestamp
 * @return boolean
 */
function rm_api_is_holiday($timestamp) {

	$tag = date('d', $timestamp);
	$monat = date('m', $timestamp);
	$jahr = date('Y', $timestamp);

	// Feste Feiertage werden nach dem Schema ddmm eingetragen
	$feiertage[] = "0101"; // Neujahrstag
	$feiertage[] = "0105"; // Tag der Arbeit
	$feiertage[] = "0310"; // Tag der Deutschen Einheit
	$feiertage[] = "2512"; // Erster Weihnachtstag
	$feiertage[] = "2612"; // Zweiter Weihnachtstag

	// Bewegliche Feiertage berechnen
	$tage = 60 * 60 * 24;
	$ostersonntag = easter_date($jahr);
	$feiertage[] = date("dm", $ostersonntag - 2 * $tage);  // Karfreitag
	$feiertage[] = date("dm", $ostersonntag + 1 * $tage);  // Ostermontag
	$feiertage[] = date("dm", $ostersonntag + 39 * $tage); // Himmelfahrt
	$feiertage[] = date("dm", $ostersonntag + 50 * $tage); // Pfingstmontag

	// PrÃ¼fen, ob Feiertag
	$code = $tag.$monat;
	if(in_array($code, $feiertage)) {
		return TRUE;
	} else {
		return FALSE;
	}
}

/**
 * Method for querying nodes by properties
 *
 * @param $type
 *      needs to be -1 if no node types are given or an array containing
 *      the node types as string values such as array('type1', 'type2')
 * @param $status
 * @param $sticky
 * @param $promote
 * @param $suppressed
 * @param $activated
 * @return array
 */
function rm_api_get_nodes_by_properties($types = -1, $status = -1, $sticky = -1, $promote = -1, $suppressed = -1, $prospect = -1, $uid = -1) {
    $resobjects = &drupal_static(__FUNCTION__, array());
    $typeoffset = json_encode($types);
    if(!isset($resobjects[$typeoffset][$status][$sticky][$promote][$suppressed][$prospect][$uid])) {
        $query = new EntityFieldQuery();
        $query->entityCondition('entity_type', 'node');
        if(is_array($types)) $query->entityCondition('bundle', $types);
        if($status >= 0) $query->propertyCondition('status', $status);
        if($sticky >= 0) $query->propertyCondition('sticky', $sticky);
        if($promote >= 0) $query->propertyCondition('promote', $promote);
        if($suppressed >= 0) $query->propertyCondition('suppressed', $suppressed);
        if($prospect >= 0) $query->propertyCondition('prospect', $prospect);
        if($uid >= 0) $query->propertyCondition('uid', $uid);
        $result = $query->execute();
        if(isset($result['node'])) {
            $resobjects[$typeoffset][$status][$sticky][$promote][$suppressed][$prospect][$uid] = entity_load('node', array_keys($result['node']));
        }
        else {
            $resobjects[$typeoffset][$status][$sticky][$promote][$suppressed][$prospect][$uid] = NULL;
        }
    }
    return $resobjects[$typeoffset][$status][$sticky][$promote][$suppressed][$prospect][$uid];
}

/**
 * Implements hook_libraries_info().
 *
 * For defining external libraries.
 */
function rm_api_libraries_info() {
    // A very simple library. No changing APIs (hence, no versions), no variants.
    // Expected to be extracted into 'sites/all/libraries/MailChimp'.

    $libraries['MailChimp'] = array(
        'name' => 'MailChimp API v2 wrapper',
        'vendor url' => 'https://github.com/drewm/mailchimp-api',
        'download url' => 'https://github.com/drewm/mailchimp-api/archive/master.zip',
        'version arguments' => array(
            'file' => 'changelog.txt',
            'pattern' => "/@version\s+([0-9\.]+)/",
            'lines' => 4,
        ),
        'files' => array(
            'php' => array('MailChimp.php'),
        ),
    );
    return $libraries;
}

/**
 * Method for subscribing an email to a MailChimp list
 *
 * Basic call:
 *      $result = rm_api_mailchimp_subscribe(
 *          'mfrericks@regiomino.de',
 *          array(
 *              'FNAME' => 'Martin',
 *              'LNAME' => 'Frericks',
 *              'SALUTATION' => 'Herr',
 *              'ROLES' => 'authenticated user'
 *          )
 *      );
 *
 * @param $email
 *      a string containing the email address, such as 'abc@gmx.de'
 *
 * @param $merge_vars
 *      an array containing values keyed by MailChimp merge tags
 *      example: array('FNAME' => 'Max', 'LNAME' => 'Mustermann', 'SALUTATION' => 'Herr')
 *
 * @param $double_optin
 *      whether the user shall receive an email to confirm his subscription (TRUE)
 *      or be subscribed without additional confirmation (FALSE -> default)
 *
 * @param $update_existing
 *      defaults to TRUE. if set to TRUE, an existing user is updated with the given information.
 *      when set to FALSE, existing user is skipped.
 *
 * @param $replace_interests
 *      no idea what this means. defaults to TRUE
 *
 * @param $send_welcome
 *      whether the user shall receive a welcome mail. defaults to FALSE.
 *
 * @return array
 *      example:
 *      Array
 *      (
 *        [email] => mfrericks@gmail.com
 *        [euid] => f24c28bee0
 *        [leid] => 225234741
 *      )
 */
function rm_api_mailchimp_subscribe($email, $merge_vars, $double_optin = FALSE, $update_existing = TRUE, $replace_interests = TRUE, $send_welcome = FALSE) {
    if (($library = libraries_load('MailChimp')) && !empty($library['loaded'])) {
        $mcapikey = variable_get('mailchimp_api_key', 'b8efb78313eadea0afdae0793d86fdef-us8');
        $MailChimp = new \Drewm\MailChimp($mcapikey);
        $result = $MailChimp->call('lists/subscribe', array(
            'id'                => '793255dd46',
            'email'             => array('email'=>$email),
            'merge_vars'        => $merge_vars,
            'double_optin'      => $double_optin,
            'update_existing'   => $update_existing,
            'replace_interests' => $replace_interests,
            'send_welcome'      => $send_welcome,
        ));
        return $result;
    }
    else {
        drupal_set_message(t('MailChimp API could not be loaded'), 'error');
    }
}

/**
 * Method for unsubscribing an email to a MailChimp list
 *
 * Basic call:
 *      $result = rm_api_mailchimp_unsubscribe('mfrericks@gmail.com');
 *
 * @param $email
 *      a string containing the email address, such as 'abc@gmx.de'
 *
 * @param $delete_member
 *      completely delete the member from your list instead of just unsubscribing, default to FALSE
 *
 * @param $send_goodbye
 *      send the goodbye email to the email address, defaults to TRUE
 *
 * @param $send_notify
 *      send the unsubscribe notification email to the address defined in the list email notification settings,
 *      defaults to TRUE
 *
 * @return array
 *      example:
 *      array(1) {
 *          ["complete"]=>
 *          bool(true)
 *      }
 */
function rm_api_mailchimp_unsubscribe($email, $delete_member = FALSE, $send_goodbye = TRUE, $send_notify = TRUE) {
    if (($library = libraries_load('MailChimp')) && !empty($library['loaded'])) {
        $mcapikey = variable_get('mailchimp_api_key', 'b8efb78313eadea0afdae0793d86fdef-us8');
        $MailChimp = new \Drewm\MailChimp($mcapikey);
        $result = $MailChimp->call('lists/unsubscribe', array(
            'id'                => '793255dd46',
            'email'             => array('email'=>$email),
            'delete_member'    => $delete_member,
            'send_goodbye'     => $send_goodbye,
            'send_notify'      => $send_notify,
        ));
        return $result;
    }
    else {
        drupal_set_message(t('MailChimp API could not be loaded'), 'error');
    }
}

/**
 * Method for sending a fax via simple-fax.de
 *
 * Basic call:
 *      $result = rm_api_send_fax('private://six_four.pdf', '032223943673');
 *
 * @param $filename
 *      A string with the filename of the pdf file that is supposed to be send, such as 'private://filename.pdf'
 *
 * @param $faxnumber
 *      A string with the complete fax number that the file is supposed to be send to
 */
function rm_api_send_fax($filename, $faxnumber, $author = 1, $faxserial = 0) {
    $fp = fopen($filename, "r");
    $data = '';
    while(!feof($fp)) $data .= fread($fp, 1024);
    $pdffile = base64_encode($data);
    require_once "SOAP/Client.php";
    $wsdl = new SOAP_WSDL("http://longisland.simple-fax.de/soap/index.php?wsdl");
    $proxy = $wsdl->getProxy();

    global $base_url;
    global $base_path;
    $response = $proxy->sendfax('support@regiomino.de', 'R3g10m1n0$', $faxnumber, $pdffile, "PDF", "Regiomino GmbH", $base_url . $base_path . 'simplefaxcallback');
    $response = preg_split("/;/", $response);
    if($response[0] == 'success') {
        $faxid = $response[1];
        //search if a fax node for this fax id already exists
        $query = new EntityFieldQuery();
        $tmp = $query
            ->entityCondition('entity_type', 'node')
            ->entityCondition('bundle', 'fax')
            ->propertyCondition('status', 1)
            ->fieldCondition('field_fax_number', 'value', $faxserial)
            ->execute();
        if(!empty($tmp['node'])) {
            //save the new attempt
            $faxnodeids = array_keys($tmp['node']);
            $faxnode = node_load($faxnodeids[0]);
            $faxnode->field_fax_attempts[LANGUAGE_NONE][] = array('first' => $faxid, 'second' => time());
            $faxnode->field_fax_status[LANGUAGE_NONE][0]['value'] = 'send again';
            node_save($faxnode);
        }
        else {
            //create new fax node
            $date = date('d.m.Y H:i:s');
            $new_node = rm_api_create_new_node('fax', 'Fax an ' . $faxnumber . ' (' . $date . ')', 'de', $author, 1);

            // Create managed File object
            $file = (object) array(
                'uid' => $author,
                'uri' => $filename,
                'filemime' => file_get_mimetype($filename),
                'status' => 1,
                'display' => 1,
            );
            // save the file to the root of the files directory.
            $file = file_copy($file, "private://fax_$faxid.pdf");
            // attach file to node
            $new_node->field_pdf[LANGUAGE_NONE][0] = (array)$file;
            // set initial fax status
            $new_node->field_fax_status[LANGUAGE_NONE][0]['value'] = 'send';
            // set first attempt
            $new_node->field_fax_attempts[LANGUAGE_NONE][] = array('first' => $faxid, 'second' => time());
            //set fax recipient
            $new_node->field_fax_recipient[LANGUAGE_NONE][0]['value'] = $faxnumber;
            node_save($new_node);
        }

        return $faxid;
    }
    else {
        $error = $response[1];
        return FALSE;
    }
}

function rm_api_simplefax_callback() {
    //load node with corresponding fax id and update status
    $queryparams = drupal_get_query_parameters();
    watchdog('simplefax_callback', print_r($queryparams, TRUE));
    $query = new EntityFieldQuery();
    $tmp = $query
        ->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'fax')
        ->propertyCondition('status', 1)
        ->fieldCondition('field_fax_attempts', 'first', $queryparams['faxid'])
        ->execute();
    if(!empty($tmp['node'])) {
        $faxnodeids = array_keys($tmp['node']);
        $faxnode = node_load($faxnodeids[0]);
        $faxnode->field_fax_status[LANGUAGE_NONE][0]['value'] = $queryparams['status'];
        if(!empty($queryparams['reason'])) {
            $reason = '<p>' . date('d.m.Y H:i:s') . ' -> ' . $queryparams['reason'] . '</p>';
        }
        else {
            $reason = '<p>' . date('d.m.Y H:i:s') . ' -> ' . t('no reason given') . '</p>';
        }
        if(!empty($faxnode->body[LANGUAGE_NONE][0]['value'])) {
            $faxnode->body[LANGUAGE_NONE][0]['value'] .= $reason;
        }
        else {
            $faxnode->body[LANGUAGE_NONE][0]['value'] = $reason;
        }
        node_save($faxnode);
        watchdog('simplefax_fax_updated', print_r($queryparams, TRUE));
    }
}

function rm_api_cron() {
    //detect all send but not delivered fax nodes that have been updated 5 minutes ago or longer
    //if number of tries equals 3 or larger set the fax to undelivered
    //if number of tries is below 3, send the fax again
    $query = new EntityFieldQuery();
    $tmp = $query
        ->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'fax')
        ->propertyCondition('status', 1)
        ->fieldCondition('field_fax_status', 'value', 'failed')
        ->execute();
    if(!empty($tmp['node'])) {
        $allfailedfaxes = entity_load('node', array_keys($tmp['node']));
        foreach($allfailedfaxes as $nid => $faxnode) {
            $attempts = count($faxnode->field_fax_attempts[LANGUAGE_NONE]);
            if($attempts >= 3) {
                //unpublish fax node
                $faxnode->status = 0;
                node_save($faxnode);
                //alert that a fax could not be delivered
                drupal_mail('rm_api', 'fax_undeliverable', 'system@regiomino.de', NULL, array('nid' => $nid, 'attempts' => $attempts), variable_get('site_mail', 'support@regiomino.de'));
            }
            else {
                //send again
                $result = rm_api_send_fax($faxnode->field_pdf[LANGUAGE_NONE][0]['uri'], $faxnode->field_fax_recipient[LANGUAGE_NONE][0]['value'], $faxnode->uid, $faxnode->field_fax_number[LANGUAGE_NONE][0]['value']);
            }
        }
    }
}

function rm_api_google_address_check($street, $zipcode, $city, $country = 'Deutschland') {
    $result = drupal_http_request('http://maps.googleapis.com/maps/api/geocode/json?address=' . urlencode($street) . ',+' . urlencode($zipcode) . '+' . urlencode($city) . ',+' . $country . '&sensor=false');
    return json_decode($result->data);
}

function rm_api_validate_google_address($gmapsdata) {
    $errors = array();
    // if($gmapsdata->status != 'OK') {
        // $errors[] = t('We cannot confirm your address. Please try again.');
    // }
    // elseif ($gmapsdata->results[0]->geometry->location_type != 'ROOFTOP') {
        // $errors[] = t('We cannot confirm your address. Please check if you entered it alright.');
    // }
    return $errors;
}

/**
 * Method for extracing address components from google maps data object
 *
 * Basic call:
 *      $result = rm_api_gmapsdata_get_element($gmapsdata, 'route');
 *
 * @param $gmapsdata
 *      An object containing gmaps data. Can be collected with rm_api_google_address_check()
 *
 * @param $element
 *      A string with the name of the element.
 *      Options:
 *          'street_number'
 *          'route'
 *          'sublocality_level_1'
 *          'sublocality_level_2'
 *          'locality'
 *          'administrative_area_level_1'
 *          'administrative_area_level_2'
 *          'country'
 *          'postal_code'
 *
 * @param $length
 *      A string to decide which version of the address component to return
 *      Options:
 *          'short_name' (default)
 *          'long_name'
 */
function rm_api_gmapsdata_get_element($gmapsdata, $element, $length = 'short_name') {
    $result = '';
    foreach($gmapsdata->results[0]->address_components as $index => $component) {
        if($component->types[0] == $element) $result = $component->{$length};
    }

    if(empty($result)) {
        return NULL;
    }
    else {
        return $result;
    }
}